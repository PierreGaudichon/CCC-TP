;;(load "path/test.ss") ;; check "path/" 
;;(load "path/ccc.ss")  ;; check "path/" 

;; SYNTACTIC ANALYSIS OF LANGUAGE WHILE

;; skips as many whitespaces as possible
;; skip-whitespace (list char) -> (list char)

(define (skip-whitespace in)
  (cond
    ((equal? in ()) in)
    ((char-whitespace? (car in)) (skip-whitespace (cdr in)))
    (else in)))

(display "skip-whitespace")
(test (skip-whitespace (list #\ #\ #\a #\b)) (list #\a #\b))
(test (skip-whitespace (list #\ #\ )) (list))
(test (skip-whitespace (list #\a #\b)) (list #\a #\b))

;; accepts empty string or whitespace
;; accept (list char) -> (mod (list char))

(define (accept in out)
  (let ((skipped-in (skip-whitespace in)))
    (begin (vector-set! out 0 skipped-in)
           (equal? skipped-in ()))))

(display "accept")
(test (let ((out (make-vector 1))) (begin (accept (list) out) out)) (vector ()))
(test (let ((out (make-vector 1))) (begin (accept (string->list "  ") out) out)) (vector ()))
(test (let ((out (make-vector 1))) 
        (begin (accept (string->list "  ab") out) out)) 
      (vector(string->list "ab") ))
(test (accept (list) (make-vector 1)) #t)
(test (accept (string->list "  ") (make-vector 1)) #t)
(test (accept (string->list "  ab") (make-vector 1)) #f)

;; returns the first k elements of a list (or less if the list is too short)
;; list-head (list any) -> int -> (list any)

(define (list-head list k)
  (cond
    ((zero? k) ())
    ((null? list) ())
    (else (cons (car list) (list-head (cdr list) (- k 1))))))

(display "list-head")
(test (list-head (list #\a #\b) 0) (list))
(test (list-head (list #\a #\b) 1) (list #\a))
(test (list-head (list #\a #\b) 2) (list #\a #\b))
(test (list-head (list #\a #\b) 3) (list #\a #\b))

;; returns the first token of a list 
;; (assuming it starts with a token of a given length)
;; car-token int -> (list char) -> (list char)

(define (car-token n l) (list-head l n))

;; returns what remains of a list after its first token 
;; (assuming it starts with a token of a given length)
;; cdr-token int -> (list char) -> (list char)

(define (cdr-token n l) (list-tail l n))

;; splits token from in
;; split-token (list char) -> (list char) -> (pair (list char) (list char))

(define (split-token token in)
  (let ((token-length (length token)))
    (if (equal? token (car-token token-length in))
        (cons token (cdr-token token-length in))
        (cons () in))))

(display "split-token")
(test (split-token (list #\a #\b) (list #\a)) 
      (cons (list) (list #\a)))
(test (split-token (list #\a #\b) (list #\a #\b)) 
      (cons (list #\a #\b) (list)))
(test (split-token (list #\a #\b) (list #\a #\b #\c)) 
      (cons (list #\a #\b) (list #\c)))

;; accepts strings starting with a given token
;; read-token string -> (list char) -> (mod (list char)) -> bool

(define (read-token token in out)
  (let* ((skipped-in (skip-whitespace in))
         (token-as-list (string->list token))
         (splitted-in (split-token token-as-list skipped-in)))
    (begin (vector-set! out 0 (cdr splitted-in))
           (equal? (car splitted-in) token-as-list))))

(display "read-token")
(test (let ((out (make-vector 1))) 
        (begin (read-token "read" (string->list "abcde") out) out))  
      (vector (string->list "abcde")))
(test (let ((out (make-vector 1))) 
        (begin (read-token "read" (string->list "read") out) out))  
      (vector ()))
(test (let ((out (make-vector 1))) 
        (begin (read-token "read" (string->list "readX") out) out))  
      (vector (string->list "X")))
(test (let ((out (make-vector 1))) 
        (begin (read-token "read" (string->list "abcde") out)))
      #f)
(test (let ((out (make-vector 1))) 
        (begin (read-token "read" (string->list "read") out)))
      #t)
(test (let ((out (make-vector 1))) 
        (begin (read-token "read" (string->list "readX") out)))
      #t)

;; splits the first upper-case characters from the rest
;; split-upper-case (list char) -> (pair (list char) (list char))

(define (split-upper-case in)
  (cond 
    ((equal? in ()) (cons () ()))
    ((char-upper-case? (car in)) 
     (let ((splitted-in (split-upper-case (cdr in))))
       (cons (cons (car in) (car splitted-in)) (cdr splitted-in))))
    (else (cons () in))))

(display "split-upper-case")
(test (split-upper-case (string->list "ABCdef")) 
      (cons (string->list "ABC") (string->list "def")))
(test (split-upper-case (string->list "ABC")) (cons (string->list "ABC") ()))
(test (split-upper-case (string->list "def")) (cons () (string->list "def")))

;; splits the first lower-case characters from the rest
;; split-lower-case (list char) -> (pair (list char) (list char))

(define (split-lower-case in)
  (cond 
    ((equal? in ()) (cons () ()))
    ((char-lower-case? (car in)) 
     (let ((splitted-in (split-lower-case (cdr in))))
       (cons (cons (car in) (car splitted-in)) (cdr splitted-in))))
    (else (cons () in))))

(display "split-lower-case")
(test (split-lower-case (string->list "abcABCdef")) 
      (cons (string->list "abc") (string->list "ABCdef")))
(test (split-lower-case (string->list "abc")) (cons (string->list "abc") ()))
(test (split-lower-case (string->list "ABCdef")) (cons () (string->list "ABCdef")))

;; splits the first numeric characters from the rest
;; split-numeric (list char) -> (pair (list char) (list char))

(define (split-numeric in)
  (cond 
    ((equal? in ()) (cons () ()))
    ((char-numeric? (car in)) 
     (let ((splitted-in (split-numeric (cdr in))))
       (cons (cons (car in) (car splitted-in)) (cdr splitted-in))))
    (else (cons () in))))

(display "split-numeric")
(test (split-numeric (string->list "123def")) 
      (cons (string->list "123") (string->list "def")))
(test (split-numeric (string->list "123")) (cons (string->list "123") ()))
(test (split-numeric (string->list "def")) (cons () (string->list "def")))

;; accepts strings starting with a constant different from
;; while for if cons car cdr nil eq nop
;; read-constant (mod string) -> (list char) -> (mod (list char)) -> bool

(define (read-constant constant in out)
  (let* ((skipped-in (skip-whitespace in))
         (splitted-in-lower-case (split-lower-case skipped-in)))
    (cond
      ((member (list->string (car splitted-in-lower-case)) (list "while" "for" "if" "cons" "car" "cdr" "nil" "eq" "nop")) 
       (begin (vector-set! out 0 skipped-in)
               #f))
      ((equal? (car splitted-in-lower-case) ())
        (begin (vector-set! out 0 skipped-in)
               #f))
      (else
        (let ((splitted-in-numeric (split-numeric (cdr splitted-in-lower-case))))
          (begin (vector-set! constant 0 
                              (list->string (append (car splitted-in-lower-case) 
                                                    (car splitted-in-numeric))))
                 (vector-set! out 0  (cdr splitted-in-numeric))
                 #t))))))

(display "read-constant")
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "while") out) out)) 
      (vector (string->list "while")))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "xyzw") out) out)) 
      (vector (string->list "")))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "XYZWxxxx") out) out)) 
      (vector (string->list "XYZWxxxx")))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "xy12xxxx") out) out)) 
      (vector (string->list "xxxx")))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "xyzw") out) const)) 
      (vector "xyzw"))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "XYZWxxxx") out) const)) 
      (vector 0))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "xy12xxxx") out) const)) 
      (vector "xy12"))
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "xyzw") out))) #t)
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "XYZWxxxx") out))) #f)
(test (let ((out (make-vector 1)) (const (make-vector 1))) 
        (begin (read-constant const (string->list "xy12xxxx") out))) #t)

;; accepts strings starting with a variable
;; read-variable (mod string) -> (list char) -> (mod (list char)) -> bool

(define (read-variable variable in out)
  (let* ((skipped-in (skip-whitespace in))
         (splitted-in-upper-case (split-upper-case skipped-in)))
    (if (equal? (car splitted-in-upper-case) ())
        (begin (vector-set! out 0 skipped-in)
               #f)
        (let ((splitted-in-numeric (split-numeric (cdr splitted-in-upper-case))))
          (begin (vector-set! variable 0 
                              (list->string (append (car splitted-in-upper-case) 
                                                    (car splitted-in-numeric))))
                 (vector-set! out 0  (cdr splitted-in-numeric))
                 #t)))))

(display "read-variable")
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "XYZW") out) out)) 
      (vector (string->list "")))
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "xxxx") out) out)) 
      (vector (string->list "xxxx")))
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "XY12xxxx") out) out)) 
      (vector (string->list "xxxx")))
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "xyzw") out) var)) 
      (vector 0))
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "XYZWxxxx") out) var)) 
      (vector "XYZW"))
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "XY12xxxx") out) var)) 
      (vector "XY12"))
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "xyzw") out))) #f)
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "XYZWxxxx") out))) #t)
(test (let ((out (make-vector 1)) (var (make-vector 1))) 
        (begin (read-variable var (string->list "XY12xxxx") out))) #t)

;; accepts lists starting with either foo, bar or zo
;; only for testing purpose
;; read-dummy (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool
;; this is the type of all non-terminals

(define (read-dummy as in out)
  (or 
   (and (read-token "foo" in out) 
        (begin (vector-set! as 0 "foo")) 
        #t)
   (and (read-token "bar" in out) 
        (begin (vector-set! as 0 "bar")) 
        #t)
   (and (read-token "zo" in out) 
        (begin (vector-set! as 0 "zo")) 
        #t)))


(display "read-dummy")
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "foo") out) as)) (vector "foo"))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "foo") out) out)) (vector ()))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "foo") out))) #t)
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "bar") out) as)) (vector "bar"))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "bar") out) out)) (vector ()))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "bar") out))) #t)
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "zo") out) as)) (vector "zo"))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "zo") out) out)) (vector ()))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "zo") out))) #t)
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "oops") out) as)) (vector 0))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "oops") out) out)) 
      (vector (string->list "oops")))
(test (let ((out (make-vector 1)) (as (make-vector 1))) 
        (begin (read-dummy as (string->list "oops") out))) #f)

;; accepts lists starting with what follows a '(' in an expression including the corresponding ')'
;; read-expression-paren (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-expression-paren as in out)
  (or
   (let ((as-car (make-vector 1)) 
         (as-cdr (make-vector 1))) 
     (and (read-token "cons" in out)
          (read-expression as-car (vector-ref out 0) out)
          (read-expression as-cdr (vector-ref out 0) out)
          (read-token ")" (vector-ref out 0) out)
          (begin (vector-set! as 0 (CONS (vector-ref as-car 0) 
                                         (vector-ref as-cdr 0)))
                 #t)))
   (let ((as-cons (make-vector 1))) 
     (and (read-token "hd" in out)
          (read-expression as-cons (vector-ref out 0) out)
          (read-token ")" (vector-ref out 0) out)
          (begin (vector-set! as 0 (HD (vector-ref as-cons 0)))
                 #t)))
   (let ((as-cons (make-vector 1)))
     (and (read-token "tl" in out)
          (read-expression as-cons (vector-ref out 0) out)
          (read-token ")" (vector-ref out 0) out)
          (begin (vector-set! as 0 (TL (vector-ref as-cons 0)))
                 #t)))))

;; accepts lists starting with a simple expression: atoms or bracketed expressions
;; read-expression1 (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-expression1 as in out)
  (let ((var (make-vector 1)) 
        (cst (make-vector 1))) 
    (or
     (and (read-variable var in out)
          (begin (vector-set! as 0 (VAR (vector-ref var 0)))
                 #t))
     (and (read-constant cst in out)
          (begin (vector-set! as 0 (CST (vector-ref cst 0)))
                 #t))
     (and (read-token "nil" in out)
          (begin (vector-set! as 0 NIL)
                 #t))
     (and (read-token "(" in out) 
          (read-expression-paren as (vector-ref out 0) out)))))

;; accepts lists starting with the '=? expr' part of an equality
;; read-expression2 (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-expression2 as in out)
  (or
   (let ((as-sub (make-vector 1)))
     (and (read-token "=?" in out)
          (read-expression as-sub (vector-ref out 0) out)
          (begin (vector-set! as 0 (lambda (x) (EQ x (vector-ref as-sub 0))))
                 #t)))
   (begin (vector-set! out 0 in)
          (vector-set! as 0 (lambda (x) x))
          #t)))

;; accepts strings starting with an expression
;; read-expression (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-expression as in out)
  (let ((as1 (make-vector 1)) 
        (as2 (make-vector 1)))
    (and (read-expression1 as1 in out)
         (read-expression2 as2 (vector-ref out 0) out)
         (begin (vector-set! as 0 ((vector-ref as2 0) (vector-ref as1 0)))
                #t))))

(display "read-expression1")
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression1 as (string->list "X12") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression1 as (string->list "X12") out) 
               as)) 
      (vector (VAR "X12")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "X12") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression1 as (string->list "x12") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression1 as (string->list "x12") out) 
               as)) 
      (vector (CST "x12")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "x12") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression1 as (string->list "while") out) 
               out)) 
      (vector (string->list "while")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression1 as (string->list "while") out) 
               as)) 
      (vector 0))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "while") out))) 
      #f)

(display "read-expression-paren")
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression-paren as (string->list "hd X)") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression-paren as (string->list "cons (hd X) (tl X))") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression-paren as (string->list "hd X)") out) 
               as)) 
      (vector (HD (VAR "X"))))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression-paren as (string->list "cons (hd X) (tl X))") out) 
               as)) 
      (vector (CONS (HD (VAR "X")) (TL (VAR "X")))))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression-paren as (string->list "hd X)") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression-paren as (string->list "cons (hd X) (tl X))") out))) 
      #t)

(display "read-expression2")
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? X12") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? cst") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? nil") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? (hd X)") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? (cons (hd X) (tl X))") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? while") out) 
               out)) 
      (vector (string->list "=? while")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? X12") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? cst") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? nil") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? (hd X)") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? (cons (hd X) (tl X))") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression2 as (string->list "=? while") out))) 
      #t)

(display "read-expression")
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "X12") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "cst") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "nil") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "(hd X)") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "(cons (hd X) (tl X))") out) 
               out)) 
      (vector ()))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "while") out) 
               out)) 
      (vector (string->list "while")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "X12") out) 
               as)) 
      (vector (VAR "X12")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "cst") out) 
               as)) 
      (vector (CST "cst")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "nil") out) 
               as)) 
      (vector NIL))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "(hd X)") out) 
               as)) 
      (vector (HD (VAR "X"))))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "(cons (hd X) (tl X))") out) 
               as)) 
      (vector (CONS (HD (VAR "X")) (TL (VAR "X")))))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "while") out) 
               as)) 
      (vector 0))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "X12") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "cst") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "nil") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "A =? B") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "A =? B") out) (vector-ref as 0))) 
      (EQ (VAR "A") (VAR "B")))
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "(hd X) ?= nil") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression 
                as (string->list "(cons (hd X) (tl X)) ?= (hd X)") out))) 
      #t)
(test (let ((as (make-vector 1)) (out (make-vector 1)))
        (begin (read-expression as (string->list "while") out))) 
      #f)

;; element x of a list of abstract syntax is represented as (lambda s)(cons x s)
;; concatenation of elements is realised as function composition

(define COMP (lambda (as1 as2) (lambda (x) (as1 (as2 x)))))

;; accepts lists starting with simple commands: everything except sequence.
;; read-command1 (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-command1 as in out)
  (let ((var (make-vector 1))
        (as-exp (make-vector 1))
        (as-count (make-vector 1))
        (as-com (make-vector 1))
        (as-com-then (make-vector 1))
        (as-com-else (make-vector 1)))
    (or (and (read-token "nop" in out) 
             (begin (vector-set! as 0 
                                 (lambda (x) 
                                   (cons NOP x)))
                    #t))
        (and (read-variable var in out) 
             (read-token ":=" (vector-ref out 0) out) 
             (read-expression as-exp (vector-ref out 0) out)
             (begin (vector-set! as 0 
                                 (lambda (x) 
                                   (cons (SET (VAR (vector-ref var 0)) 
                                              (vector-ref as-exp 0)) 
                                         x)))
                    #t))
        (and (read-token "while" in out)
             (read-expression as-exp (vector-ref out 0) out)
             (read-token "do" (vector-ref out 0) out)
             (read-command as-com (vector-ref out 0) out)
             (read-token "od" (vector-ref out 0) out)
             (begin (vector-set! as 0 
                                 (lambda (x) 
                                   (cons (WHILE (vector-ref as-exp 0) 
                                                ((vector-ref as-com 0) ())) 
                                         x)))
                    #t))
        (and (read-token "for" in out)
             (read-expression as-count (vector-ref out 0) out)
             (read-token "do" (vector-ref out 0) out)
             (read-command as-com (vector-ref out 0) out)
             (read-token "od" (vector-ref out 0) out)
             (begin (vector-set! as 0 
                                 (lambda (x) 
                                   (cons (FOR (vector-ref as-count 0)
                                              ((vector-ref as-com 0) ())) 
                                         x)))
                    #t))
        (and (read-token "if" in out)
             (read-expression as-exp (vector-ref out 0) out)
             (read-token "then" (vector-ref out 0) out)
             (read-command as-com-then (vector-ref out 0) out)
             (read-token "else" (vector-ref out 0) out)
             (read-command as-com-else (vector-ref out 0) out)
             (read-token "fi" (vector-ref out 0) out)
             (begin (vector-set! as 0 
                                 (lambda (x) 
                                   (cons (IF (vector-ref as-exp 0) 
                                             ((vector-ref as-com-then 0) ())
                                             ((vector-ref as-com-else 0) ())) 
                                         x)))
                    #t)))))

;; accepts lists starting with '; commands'
;; read-commandN (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-commandN as in out)
  (let ((as-com (make-vector 1)))
    (or (and (read-token ";" in out)
             (read-command as-com (vector-ref out 0) out)
             (begin (vector-set! as 0 (vector-ref as-com 0))
                    #t))
        (begin (vector-set! as 0 (lambda (x) x))
               #t))))

;; accepts lists starting with a command
;; read-command (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-command as in out)
  (let ((as-com1 (make-vector 1))
        (as-com2 (make-vector 1)))
    (and (read-command1 as-com1 in out)
         (read-commandN as-com2 (vector-ref out 0) out)
         (begin
           (vector-set! as 0 (COMP (vector-ref as-com1 0) 
                                      (vector-ref as-com2 0)))
           #t))))

(display "read-command1")
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command1 as (string->list "nop") out)  
               ((vector-ref as 0) ()))) 
      (list NOP))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command1 as (string->list "for X do nop od") out)  
               ((vector-ref as 0) ()))) 
      (list (FOR (VAR "X") (list NOP))))

(display "read-command")
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "nop") out)  
               ((vector-ref as 0) ()))) 
      (list NOP))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "for X do nop od") out)  
               ((vector-ref as 0) ()))) 
      (list (FOR (VAR "X") (list NOP))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "for X do A := B od") out)  
               ((vector-ref as 0) ()))) 
      (list (FOR (VAR "X") (list (SET (VAR "A") (VAR "B"))))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command1 as (string->list "if X =? Y then nop else nop fi") out)  
               ((vector-ref as 0) ()))) 
      (list (IF (EQ (VAR "X") (VAR "Y"))
                (list NOP)
                (list NOP))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command1 as (string->list "for X =? Y do nop od") out)  
               ((vector-ref as 0) ()))) 
      (list (FOR (EQ (VAR "X") (VAR "Y"))
                 (list NOP))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command1 as (string->list "for X do nop od") out)  
               ((vector-ref as 0) ()))) 
      (list (FOR (VAR "X") (list NOP))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "X:=Y ; A := B") out)  
               ((vector-ref as 0) ()))) 
      (list (SET (VAR "X") (VAR "Y")) 
            (SET (VAR "A") (VAR "B"))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "X:=Y ; nop ; A := B") out)  
               ((vector-ref as 0) ()))) 
      (list (SET (VAR "X") (VAR "Y")) 
            NOP 
            (SET (VAR "A") (VAR "B"))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "X:=Y ; A := B ; U := V") out) 
               ((vector-ref as 0) ())))
      (list (SET (VAR "X") (VAR "Y")) 
            (SET (VAR "A") (VAR "B")) 
            (SET (VAR "U") (VAR "V"))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "X:=Y ; if A =? B then U := V else D := F ; K := L fi ; R := T fi") out) 
               ((vector-ref as 0) ())))
      (list (SET (VAR "X") (VAR "Y")) 
            (IF (EQ (VAR "A") (VAR "B")) 
                (list (SET (VAR "U") (VAR "V"))) 
                (list (SET (VAR "D") (VAR "F")) 
                      (SET (VAR "K") (VAR "L")))) 
            (SET (VAR "R") (VAR "T"))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "if A =? B then U := V else X := Y fi") out) 
               ((vector-ref as 0) ())))
      (list (IF (EQ (VAR "A") (VAR "B"))
                 (list (SET (VAR "U") (VAR "V"))) 
                 (list (SET (VAR "X") (VAR "Y"))))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "if A =? B then U := V else X := Y fi") out) 
               ((vector-ref as 0) ())))
      (list (IF (EQ (VAR "A") (VAR "B"))
                 (list (SET (VAR "U") (VAR "V"))) 
                 (list (SET (VAR "X") (VAR "Y"))))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "for A =? B do U := V od") out) 
               ((vector-ref as 0) ())))
      (list (FOR (EQ (VAR "A") (VAR "B"))
                 (list (SET (VAR "U") (VAR "V"))))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-command as (string->list "X:=Y ; for A =? B do U := V ; D := F ; K := L od ; R := T") out) 
               ((vector-ref as 0) ())))
      (list (SET (VAR "X") (VAR "Y")) 
            (FOR (EQ (VAR "A") (VAR "B"))
                 (list (SET (VAR "U") (VAR "V")) 
                       (SET (VAR "D") (VAR "F"))
                       (SET (VAR "K") (VAR "L"))))
            (SET (VAR "R") (VAR "T"))))

;; accepts lists starting with a program
;; read-program (mod abstract-syntax) -> (list char) -> (mod (list char)) -> bool

(define (read-program as in out)
  (let ((var-in (make-vector 1))
        (as-com (make-vector 1))
        (var-out (make-vector 1)))
    (and (read-token "read" in out)
         (read-variable var-in (vector-ref out 0) out)
         (read-token "%" (vector-ref out 0) out)
         (read-command as-com (vector-ref out 0) out)
         (read-token "%" (vector-ref out 0) out)
         (read-token "write" (vector-ref out 0) out)
         (read-variable var-out (vector-ref out 0) out)
         (begin (vector-set! as 0 
                             (PROGR (list (VAR (vector-ref var-in 0))) 
                                    ((vector-ref as-com 0) ()) 
                                    (list (VAR (vector-ref var-out 0)))))
                #t))))

(display "read-program")
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-program as 
                             (string->list "read X123 % X := Y % write ABC") 
                             out) 
               as))
      (vector (PROGR (list (VAR "X123")) 
                     (list (SET (VAR "X") (VAR "Y"))) 
                     (list (VAR "ABC")))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-program as 
                             (string->list "readX%X:=Y%writeW") 
                             out)
               as)) 
      (vector (PROGR (list (VAR "X")) 
                     (list (SET (VAR "X") (VAR "Y"))) 
                     (list (VAR "W")))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-program as 
                             (string->list 
                              "read X
%
X := Y
%
write Y")
                             out)
               as)) 
      (vector (PROGR (list (VAR "X")) 
                     (list (SET (VAR "X") (VAR "Y"))) 
                     (list (VAR "Y")))))
(test (let ((as (make-vector 1)) (out (make-vector 1))) 
        (begin (read-program as 
                             (string->list 
                              "read X 
% 
Y := nil ; 
while X do 
      Y := (cons (hd X) Y) ; 
      X := (tl X) od 
% 
write Y")
                             out)
               as)) 
      (vector (PROGR (list (VAR "X")) 
                     (list (SET (VAR "Y") NIL) 
                           (WHILE (VAR "X") 
                                  (list (SET (VAR "Y") (CONS (HD (VAR "X")) (VAR "Y"))) 
                                        (SET (VAR "X") (TL (VAR "X"))))) )
                     (list (VAR "Y")))))

;; accepts lists representing exactly WHILE programs
;; read-while-program string -> abstract-syntax U error-report
;; this is the only public function

(define (read-while-program in)
  (let ((as (make-vector 1))
        (out (make-vector 1)))
    (if (and (read-program as (string->list in) out)
             (accept (vector-ref out 0) out))
        (vector-ref as 0)
        (ERROR "Invalid program"))))

(display "read-while-program")
(test (read-while-program  "readX%X:=Y%writeW:=Z")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:=Y%write")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:=Y%w")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:=Y%")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:=Y")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:=")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%")
      (ERROR "Invalid program"))
(test (read-while-program  "readX")
      (ERROR "Invalid program"))
(test (read-while-program  "readX:=Y")
      (ERROR "Invalid program"))
(test (read-while-program  "read")
      (ERROR "Invalid program"))
(test (read-while-program  "re")
      (ERROR "Invalid program"))
(test (read-while-program  "")
      (ERROR "Invalid program"))
(test (read-while-program  "readX%X:=Y%writeW")
      (PROGR (list (VAR "X")) 
             (list (SET (VAR "X") (VAR "Y"))) 
             (list (VAR "W"))))
(test (read-while-program 
       "read X
%
X := Y
%
write Y")
      (PROGR (list (VAR "X")) 
             (list (SET (VAR "X") (VAR "Y"))) 
             (list (VAR "Y"))))
(test (read-while-program 
       "read X 
% 
Y := nil ; 
while X do 
      Y := (cons (hd X) Y) ; 
      X := (tl X) od 
% 
write Y")
      (PROGR (list (VAR "X")) 
             (list (SET (VAR "Y") NIL) 
                   (WHILE (VAR "X") 
                          (list (SET (VAR "Y") (CONS (HD (VAR "X")) (VAR "Y"))) 
                                (SET (VAR "X") (TL (VAR "X"))))) )
             (list (VAR "Y"))))



